package org.firstinspires.ftc.teamcode;

import com.qualcomm.robotcore.eventloop.opmode.OpMode;
import com.qualcomm.robotcore.eventloop.opmode.OpMode;
import com.qualcomm.robotcore.hardware.ColorSensor;
import com.qualcomm.robotcore.eventloop.opmode.TeleOp;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.hardware.Servo;
import com.qualcomm.robotcore.hardware.CRServo;
import com.qualcomm.robotcore.hardware.ColorSensor;

@TeleOp(name = "AdvColorRecognition" )
public class AdvColorRecognition extends OpMode {
   DcMotor LF;
   DcMotor RF;
   DcMotor RR;
   DcMotor LR;
   CRServo CR;
   Servo TrayServo;
   ColorSensor colorsensor;
   ColorSensor purplesensor;
   double side;
   double y1;
   double x1;
   double y2;
   double x2;

   private boolean aUp = false;
   private boolean lastastate = false;
@Override
public void init() {
   LF = hardwareMap.get(DcMotor.class, "LF");
   RF = hardwareMap.get(DcMotor.class, "RF");
   RR = hardwareMap.get(DcMotor.class, "RR");
   LR = hardwareMap.get(DcMotor.class, "LR");
   CR = hardwareMap.get(CRServo.class, "CR");

   colorsensor = hardwareMap.get(ColorSensor.class, "colorsensor");
   purplesensor = hardwareMap.get(ColorSensor.class, "purplesensor");



@Override
public void loop() {
   // for colorsensor
       int Colorred = colorSensor.red();
       int Colorblue = colorSensor.blue();
       int Colorgreen = colorSensor.green();
       int Coloralpha = colorSensor.alpha();
       boolean Colorpurple = (Colorred > 100 && Colorblue > 100 && Colorgreen < 80);
      //for purple sensor
       int  Purplered = puprlesensor.red();
       int Purpleblue = purplesensor.blue();
       int Purplegreen = purplesensor.green();
       int purplealpha = purplesensor.alpha();
       boolean Purplepurple = (Purplered > 100 && Colorblue > 100 && Colorgreen < 80);



       telemetry.addData("Red", Colorred);
       telemetry.addData("Green", Colorgreen);
       telemetry.addData("Blue", Colorblue);
       telemetry.addData("Purple", Colorpurple);
       telemetry.update();

   side = gamepad1.right_stick_x;


   if (Math.abs(side) > 0.05) {
       //strafing
       if (gamepad1.left_bumper) {
           LF.setPower(side * 0.2);
           LR.setPower(side * -0.2);
           RF.setPower(side * -0.2);
           RR.setPower(side * -0.2);
       } else {
           LF.setPower(side * 0.8);
           LR.setPower(side * -0.8);
           RF.setPower(side * -0.8);
           RR.setPower(side * 0.8);
       }
   } else {
       //moving forward/backward and left/right
       y1 = -gamepad1.left_stick_y;
       x1 = gamepad1.left_stick_x;
       y2 = x1 * 0.85 + y1;
       x2 = y1 - x1 * 0.85;


       if (gamepad1.left_bumper) {
           LF.setPower(y2 * 0.2);
           LR.setPower(y2 * 0.2);
           RF.setPower(x2 * 0.2);
           RR.setPower(x2 * 0.2);
       } else {
           LF.setPower(y2 * 0.8);
           LR.setPower(y2 * 0.8);
           RF.setPower(x2 * 0.8);
           RR.setPower(x2 * 0.8);
       }


   }
if(gamepad1.a && !lastastate){
   CR.setPower(aUp ? 0:1);
}
lastastate = gamepad1.a;
// -----Change this to be triggered by color sensor- nvm keeping both for now heheh------
if(gamepad1.dpad_up){
   TrayServo.setPosition(0.2);
}
if(gamepad1.dpad_left){
   TrayServo.setPosition(0.5)
}
if(gamepad1.dpad_right){
   TrayServo.setPosition(1);
}

if(green > red && green > blue){
   TrayServo.setPositon(0.2);
}
if(Colorpurple && Purplepurple){
   TrayServo.setPosition(0.5);
}
if(Colorpurple && Purplepurple = false){
   TrayServo.setPosition(1);
}
}
}




