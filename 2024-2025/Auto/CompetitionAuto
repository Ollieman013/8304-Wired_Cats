package org.firstinspires.ftc.teamcode;/* Copyright (c) 2017 FIRST. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted (subject to the limitations in the disclaimer below) provided that
 * the following conditions are met:
 *
 * Redistributions of source code must retain the above copyright notice, this list
 * of conditions and the following disclaimer.
 *
 * Redistributions in binary form must reproduce the above copyright notice, this
 * list of conditions and the following disclaimer in the documentation and/or
 * other materials provided with the distribution.
 *
 * Neither the name of FIRST nor the names of its contributors may be used to endorse or
 * promote products derived from this software without specific prior written permission.
 *
 * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS
 * LICENSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */



import java.util.ArrayList;
import org.firstinspires.ftc.vision.apriltag.AprilTagDetection;
import org.firstinspires.ftc.robotcore.external.hardware.camera.WebcamName;
import com.qualcomm.robotcore.eventloop.opmode.Autonomous;
import java.lang.annotation.Target;
import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.hardware.DcMotorEx;
import com.qualcomm.robotcore.util.ElapsedTime;
import org.openftc.easyopencv.OpenCvCamera;

@Autonomous(name="Robot: Auto_Strafe_Place_Left", group="Robot")

public class Auto_R_Strafe_Place_Left extends LinearOpMode {
    HardwareMecanum robot = new HardwareMecanum();
    /* Declare OpMode members. */
    //OpenCvCamera camera;
    //AprilTagDetectionPipeline aprilTagDetectionPipeline;

    static final double FEET_PER_METER = 3.28084;


    private ElapsedTime runtime = new ElapsedTime();

    // Calculate the COUNTS_PER_INCH for your specific drive train.
    // Go to your motor vendor website to determine your motor's COUNTS_PER_MOTOR_REV
    // For external drive gearing, set DRIVE_GEAR_REDUCTION as needed.
    // For example, use a value of 2.0 for a 12-tooth spur gear driving a 24-tooth spur gear.
    // This is gearing DOWN for less speed and more torque.
    // For gearing UP, use a gear ratio less than 1.0. Note this will affect the direction of wheel rotation.
    static final double COUNTS_PER_MOTOR_REV = 537.7;
    static final double DRIVE_GEAR_REDUCTION = 1.0;     // No External Gearing.
    static final double WHEEL_DIAMETER_INCHES = 3.78;     // For figuring circumference
    static final double COUNTS_PER_INCH = (COUNTS_PER_MOTOR_REV * DRIVE_GEAR_REDUCTION) /
            (WHEEL_DIAMETER_INCHES * 3.14159);

    @Override
    public void runOpMode() {



        robot.init(hardwareMap);
        robot.Twist.setPosition(0.99);
        robot.Grab.setPosition(0.67);
        waitForStart();
        liftrun(0.63,1);
        robot.Lift.setPower(-0.05);

        encoderDrive(0.7,20,20,4);

        encodersideDrive(0.7,16,2);
        robot.Twist.setPosition(0.32);
        encoderDrive(0.5,15,15,2);
        encoderDrive(0.3,-1.5,-1.5,1);
        liftrun(0.5,-0.6);
        robot.Grab.setPosition(0.83);
        liftrun(0.1,0.2);
        encoderDrive(0.2,-5,-5,1);
        robot.Twist.setPosition(0.99);
        liftrun(0.1,-1);
        encodersideDrive(0.8,-35,3);
        sleep(200);
        encoderDrive(0.8,25,25,3);
        encodersideDrive(0.4,-12,3);
        encoderDrive(1,-45,-45,3);
        sleep(200);
        /*
        encoderDrive(0.9,45,45,3);
        sleep(200);
        encodersideDrive(0.5,-13,2);
        encoderDrive(0.9,-45,-45,3);
        sleep(200);

        */
        encoderDrive(0.4,13,13,1);
        //encodersideDrive(0.4,12,1);
        sleep(1000);
        encoderDrive(0.5,-22,-22,4);
        robot.Grab.setPosition(0.67);
        sleep(200);
        liftrun(0.65,1);
        robot.Lift.setPower(-0.05);
        encoderDrive(0.8,20,20,3);
        robot.Twist.setPosition(0.32);
        encodersideDrive(1,56,3);
        encoderDrive(0.5,15,15,2);
        encoderDrive(0.2,-1.5,-1.5,1);
        liftrun(0.5,-0.6);
        robot.Grab.setPosition(0.83);
        liftrun(0.1,0.2);
        robot.Twist.setPosition(0.99);
        liftrun(0.15,-1);
        encoderDrive(0.7,-8,-8,1);
        encodersideDrive(1,-53,2);
        sleep(500);
        encoderDrive(0.6,-24,-24,1);
        robot.Grab.setPosition(0.67);
        sleep(175);
        liftrun(0.66,1);
        robot.Lift.setPower(-0.05);
        encoderDrive(0.9,15,15,1);
        encodersideDrive(1,46,2);
        robot.Twist.setPosition(0.32);
        encoderDrive(0.5,20,20,1);
        encoderDrive(0.3,-1.5,-1.5,1);
        liftrun(0.5,-0.6);
        robot.Grab.setPosition(0.83);
        encoderDrive(1,-32,-32,1);
        encodersideDrive(1,-50,1);
        /*
        robot.IntakeS.setPosition(0.4);
        encoderDrive(0.4,-27,-27,50);
        encodersideDrive(0.2,2,1);
        turn(-90,3);
        encoderDrive(0.1,-2,-2,1);
        Intake(0.5,0.64);
        encoderDrive(0.1,3,3,1);
        encodersideDrive(0.4,27,5);
        encoderDrive(0.4,-75,-75,10);
        encodersideDrive(0.4,-33,5);
        turn(180,3);
        sleep(200);
        liftrun(1,0.5);
        robot.LiftL.setPower(-0.05);
        robot.LiftR.setPower(-0.05);
        robot.Twist.setPosition(0.45);
        sleep(1000);
        encoderDrive(0.2,17,17,3);
        sleep(500);
        robot.Grip.setPosition(0.52);
        sleep(100);
        encoderDrive(0.1,-6,-6,1);
        robot.Grip.setPosition(0.47);
        robot.Twist.setPosition(0.1);
        sleep(1000);
        liftrun(1,-0.5);
*/



        telemetry.addData("Path", "Complete");
        telemetry.update();
        sleep(1000);  // pause to display final telemetry message.
    }


    public void encoderDrive(double speed,
                             double leftInches, double rightInches,
                             double timeoutS) {
        int newLeftFrontTarget;
        int newRightFrontTarget;
        int newRightRearTarget;
        int newLeftRearTarget;

        // Ensure that the opmode is still active
        if (opModeIsActive()) {

            // Determine new target position, and pass to motor controller
            newLeftFrontTarget = robot.LeftFront.getCurrentPosition() + (int)(leftInches * COUNTS_PER_INCH);
            newRightRearTarget = robot.RightRear.getCurrentPosition() + (int)(rightInches * COUNTS_PER_INCH);
            newRightFrontTarget = robot.RightFront.getCurrentPosition() + (int)(rightInches * COUNTS_PER_INCH);
            newLeftRearTarget = robot.LeftRear.getCurrentPosition() + (int)(rightInches * COUNTS_PER_INCH);

            robot.LeftFront.setTargetPosition(newLeftFrontTarget);
            robot.LeftRear.setTargetPosition(newLeftRearTarget);
            robot.RightFront.setTargetPosition(newRightFrontTarget);
            robot.RightRear.setTargetPosition(newRightRearTarget);



            // Turn On RUN_TO_POSITION
            robot.LeftRear.setMode(DcMotor.RunMode.RUN_TO_POSITION);
            robot.LeftFront.setMode(DcMotor.RunMode.RUN_TO_POSITION);
            robot.RightRear.setMode(DcMotor.RunMode.RUN_TO_POSITION);
            robot.RightFront.setMode(DcMotor.RunMode.RUN_TO_POSITION);
            // reset the timeout time and start motion.
            runtime.reset();
            robot.LeftFront.setPower(speed);
            robot.LeftRear.setPower(speed);
            robot.RightFront.setPower(speed);
            robot.RightRear.setPower(speed);

            // keep looping while we are still active, and there is time left, and both motors are running.
            // Note: We use (isBusy() && isBusy()) in the loop test, which means that when EITHER motor hits
            // its target position, the motion will stop.  This is "safer" in the event that the robot will
            // always end the motion as soon as possible.
            // However, if you require that BOTH motors have finished their moves before the robot continues
            // onto the next step, use (isBusy() || isBusy()) in the loop test.
            while (opModeIsActive() &&
                    (runtime.seconds() < timeoutS) &&
                    (robot.LeftRear.isBusy() && robot.LeftFront.isBusy()&& robot.RightRear.isBusy() && robot.RightFront.isBusy())) {

                // Display it for the driver.
                telemetry.addData("Running to",  " %7d :%7d :%7d :%7d", newLeftFrontTarget,  newRightFrontTarget, newLeftRearTarget, newRightRearTarget);
                telemetry.addData("Currently at",  " at %7d :%7d :%7d :%7d",
                        robot.LeftFront.getCurrentPosition(), robot.RightFront.getCurrentPosition(),
                        robot.LeftRear.getCurrentPosition(), robot.RightRear.getCurrentPosition());
                telemetry.update();
            }


            // Stop all motion;
            robot.LeftFront.setPower(0);
            robot.RightFront.setPower(0);
            robot.LeftRear.setPower(0);
            robot.RightRear.setPower(0);
            // Turn off RUN_TO_POSITION
            robot.RightFront.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
            robot.LeftFront.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
            robot.RightRear.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
            robot.LeftRear.setMode(DcMotor.RunMode.RUN_USING_ENCODER);

            sleep(50);   // optional pause after each move.
        }
    }

    public void encodersideDrive(double speed,
                                 double sideDist,
                                 double timeoutS) {
        int sideLFRRTarget;
        int sideRFLRTarget;


        // Ensure that the opmode is still active
        if (opModeIsActive()) {
            robot.LeftFront.setMode(DcMotorEx.RunMode.STOP_AND_RESET_ENCODER);
            robot.RightFront.setMode(DcMotorEx.RunMode.STOP_AND_RESET_ENCODER);
            robot.LeftRear.setMode(DcMotorEx.RunMode.STOP_AND_RESET_ENCODER);
            robot.RightRear.setMode(DcMotorEx.RunMode.STOP_AND_RESET_ENCODER);
            // Determine new target position, and pass to motor controller
            sideLFRRTarget = robot.LeftFront.getCurrentPosition() - (int)(sideDist * COUNTS_PER_INCH);
            sideRFLRTarget = robot.LeftRear.getCurrentPosition() + (int)(sideDist * COUNTS_PER_INCH);
            robot.LeftFront.setTargetPosition(sideLFRRTarget);
            robot.LeftRear.setTargetPosition(sideRFLRTarget);
            robot.RightFront.setTargetPosition(sideRFLRTarget);
            robot.RightRear.setTargetPosition(sideLFRRTarget);

            // Turn On RUN_TO_POSITION
            robot.LeftRear.setMode(DcMotor.RunMode.RUN_TO_POSITION);
            robot.LeftFront.setMode(DcMotor.RunMode.RUN_TO_POSITION);
            robot.RightRear.setMode(DcMotor.RunMode.RUN_TO_POSITION);
            robot.RightFront.setMode(DcMotor.RunMode.RUN_TO_POSITION);
            // reset the timeout time and start motion.
            runtime.reset();
            robot.LeftFront.setPower(speed);
            robot.LeftRear.setPower(speed);
            robot.RightFront.setPower(speed);
            robot.RightRear.setPower(speed);

            // keep looping while we are still active, and there is time left, and both motors are running.
            // Note: We use (isBusy() && isBusy()) in the loop test, which means that when EITHER motor hits
            // its target position, the motion will stop.  This is "safer" in the event that the robot will
            // always end the motion as soon as possible.
            // However, if you require that BOTH motors have finished their moves before the robot continues
            // onto the next step, use (isBusy() || isBusy()) in the loop test.
            while (opModeIsActive() &&
                    (runtime.seconds() < timeoutS) &&
                    (robot.LeftRear.isBusy() && robot.LeftFront.isBusy()&& robot.RightRear.isBusy() && robot.RightFront.isBusy())) {

                // Display it for the driver.
                telemetry.addData("Running to",  " %7d :%7d", sideLFRRTarget,  sideRFLRTarget);
                telemetry.addData("Currently at",  " at %7d :%7d :%7d :%7d",
                        robot.LeftFront.getCurrentPosition(), robot.RightFront.getCurrentPosition(),
                        robot.LeftRear.getCurrentPosition(), robot.RightRear.getCurrentPosition());
                telemetry.update();
            }

            // Stop all motion;
            robot.LeftFront.setPower(0);
            robot.RightFront.setPower(0);
            robot.LeftRear.setPower(0);
            robot.RightRear.setPower(0);
            // Turn off RUN_TO_POSITION
            robot.RightFront.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
            robot.LeftFront.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
            robot.RightRear.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
            robot.LeftRear.setMode(DcMotor.RunMode.RUN_USING_ENCODER);

            sleep(50);   // optional pause after each move.
        }
    }

    public void liftrun(double TargetTime, double speed)
    {
        if(opModeIsActive())
        {
            runtime.reset();
            robot.Lift.setPower(-speed);
            while(opModeIsActive()&&runtime.seconds()<TargetTime)
            {
            }
            sleep(50);
        }

    }

    public void turn(double degrees, double timeoutS)
    {
        double wheeldistance=27.3;
        double circumference= wheeldistance* COUNTS_PER_INCH * Math.PI;
        double turnLeftTarget=0;
        double turnRightTarget=0;
        turnLeftTarget=circumference*degrees/360;
        turnRightTarget=-circumference*degrees/360;
        int newLeftFrontTurn;
        int newRightFrontTurn;
        int newRightRearTurn;
        int newLeftRearTurn;
        if(opModeIsActive())
        {
            newLeftFrontTurn = robot.LeftFront.getCurrentPosition() + (int)(turnLeftTarget);
            newRightRearTurn = robot.RightRear.getCurrentPosition() + (int)(turnRightTarget);
            newRightFrontTurn = robot.RightFront.getCurrentPosition() + (int)(turnRightTarget);
            newLeftRearTurn = robot.LeftRear.getCurrentPosition() + (int)(turnLeftTarget);

            robot.LeftFront.setTargetPosition(newLeftFrontTurn);
            robot.LeftRear.setTargetPosition(newLeftRearTurn);
            robot.RightFront.setTargetPosition(newRightFrontTurn);
            robot.RightRear.setTargetPosition(newRightRearTurn);



            // Turn On RUN_TO_POSITION
            robot.LeftRear.setMode(DcMotor.RunMode.RUN_TO_POSITION);
            robot.LeftFront.setMode(DcMotor.RunMode.RUN_TO_POSITION);
            robot.RightRear.setMode(DcMotor.RunMode.RUN_TO_POSITION);
            robot.RightFront.setMode(DcMotor.RunMode.RUN_TO_POSITION);
            // reset the timeout time and start motion.
            runtime.reset();
            robot.LeftFront.setPower(0.3);
            robot.LeftRear.setPower(0.3);
            robot.RightFront.setPower(0.3);
            robot.RightRear.setPower(0.3);

            while (runtime.seconds() < timeoutS && opModeIsActive() && (robot.LeftRear.isBusy() && robot.LeftFront.isBusy()&& robot.RightRear.isBusy() && robot.RightFront.isBusy()))
            {
                telemetry.addData("Turning at",  " at %7d :%7d :%7d :%7d",
                        robot.LeftFront.getCurrentPosition(), robot.RightFront.getCurrentPosition(),
                        robot.LeftRear.getCurrentPosition(), robot.RightRear.getCurrentPosition());
                telemetry.update();
            }
            robot.LeftFront.setPower(0);
            robot.RightFront.setPower(0);
            robot.LeftRear.setPower(0);
            robot.RightRear.setPower(0);
            // Turn off RUN_TO_POSITION
            robot.RightFront.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
            robot.LeftFront.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
            robot.RightRear.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
            robot.LeftRear.setMode(DcMotor.RunMode.RUN_USING_ENCODER);

            sleep(50);
        }
    }
}

