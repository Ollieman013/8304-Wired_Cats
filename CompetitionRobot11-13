package org.firstinspires.ftc.teamcode;

import com.qualcomm.robotcore.eventloop.opmode.OpMode;
import com.qualcomm.robotcore.hardware.CRServo;
import com.qualcomm.robotcore.eventloop.opmode.OpMode;
import com.qualcomm.robotcore.hardware.ColorSensor;
import com.qualcomm.robotcore.eventloop.opmode.TeleOp;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.hardware.Servo;
import com.qualcomm.robotcore.hardware.ColorSensor;
import com.qualcomm.robotcore.util.ElapsedTime;


@TeleOp(name = "CompetitionRobot11-13" )
public class CompetitionRobot11-13 extends OpMode {
   DcMotor LF;
   DcMotor RF;
   DcMotor RR;
   DcMotor LR;


   CRServo cont1;
   CRServo cont2;
   CRServo cont3;
   CRServo Switch;
   CRServo rey1;
   CRServo rey2;
   CRServo rey3;
   CRServo rey4;

   DcMotor spin;
   DcMotor twin;
   CRServo turn;
   CRServo burn;
   CRServo lurn;

   DcMotor Up;
   DcMotor Bup;

   Servo ro;
   Servo bo;
   Servo leftMove;
   Servo leftGate;
   Servo rightMove;
   Servo rightGate;


   ColorSensor colorSensor;
   double side;
   double y1;
   double x1;
   double y2;
   double x2;


   private boolean contUp = false;
   private boolean lastBstate = false;
   private boolean currentBstate = false;


   private boolean lastXstate = false;
   private boolean xUp = false;
   private boolean currentXstate = false;
   private boolean lastYstate = false;
   private boolean yUp = false;
   private boolean currentYstate = false;
   private boolean currentAstate = false;
   private boolean aUp = false;
   private boolean lastAstate = false;
   private boolean lastupstate = false;
   private boolean up = false;
   private boolean lastdownstate = false;
   private boolean down = false;


   private ElapsedTime runtime = new ElapsedTime(); // Declare and initialize ElapsedTime
   @Override
   public void init() {
       LF = hardwareMap.get(DcMotor.class, "LF");
       RF = hardwareMap.get(DcMotor.class, "RF");
       RR = hardwareMap.get(DcMotor.class, "RR");
       LR = hardwareMap.get(DcMotor.class, "LR");


       cont1 = hardwareMap.get(CRServo.class, "cont1");
       cont2 = hardwareMap.get(CRServo.class, "cont2");
       cont3 = hardwareMap.get(CRServo.class, "cont3");


       Switch = hardwareMap.get(CRServo.class, "Switch");
       rey1 = hardwareMap.get(CRServo.class, "rey1");
       rey2 = hardwareMap.get(CRServo.class, "rey2");
       rey3 = hardwareMap.get(CRServo.class, "rey3");
       rey4 = hardwareMap.get(CRServo.class, "rey4");

       leftMove = hardwareMap.get(Servo.class, "leftMove");
       leftGate = hardwareMap.get(Servo.class, "leftGate");
       rightMove = hardwareMap.get(Servo.class, "rightMove");
       rightGate = hardwareMap.get(Servo.class, "rightGate");


       colorSensor = hardwareMap.get(ColorSensor.class, "colorSensor");


       turn = hardwareMap.get(CRServo.class, "turn");
       burn = hardwareMap.get(CRServo.class, "burn");
       lurn = hardwareMap.get(CRServo.class, "lurn");
       spin = hardwareMap.get(DcMotor.class, "spin");
       twin = hardwareMap.get(DcMotor.class, "twin");

       Up = hardwareMap.get(DcMotor.class, "Up");
       Bup = hardwareMap.get(DcMotor.class, "Bup");

       ro = hardwareMap.get(Servo.class, "ro");
       bo = hardwareMap.get(Servo.class, "bo");
       ro.setPosition(1);
       bo.setPosition(0.53);

       leftMove.setPosition(0);
       leftGate.setPosition(0);

       //stuff for time crservos >:(
       private boolean switchRunning = false;
       private boolean rey12Running = false;
       private boolean rey34Running = false;
       private double switchStartTime = 0;
       private double rey12StartTime = 0;
       private double rey34StartTime = 0;

       private boolean leftRunning = false;
       private boolean rightRunning = false;
       private double leftStartTime = 0;
       private double rightStartTime = 0;
       runtime.reset(); //resets timer each time
   }
   @Override
   public void loop(){

       side = gamepad1.right_stick_x;

       if (Math.abs(side) > 0.05) {
           //strafing
           if (gamepad1.left_bumper) {
               LF.setPower(side * -0.2);
               LR.setPower(side * 0.2);
               RF.setPower(side * -0.2);
               RR.setPower(side * 0.2);
           } else {
               LF.setPower(side * -0.8);
               LR.setPower(side * 0.8);
               RF.setPower(side * -0.8);
               RR.setPower(side * 0.8);
           }
       } else {
           //moving forward/backward and left/right
           y1 = -gamepad1.left_stick_y;
           x1 = gamepad1.left_stick_x;
           y2 = x1 * 0.85 + y1;
           x2 = y1 - x1 * 0.85;


           if (gamepad1.left_bumper) {
               LF.setPower(y2 * -0.2);
               LR.setPower(y2 * -0.2);
               RF.setPower(x2 * 0.2);
               RR.setPower(x2 * 0.2);
           } else {
               LF.setPower(y2 * -0.8);
               LR.setPower(y2 * -0.8);
               RF.setPower(x2 * 0.8);
               RR.setPower(x2 * 0.8);
           }


       }

       int red = colorSensor.red();
       int blue = colorSensor.blue();
       int green = colorSensor.green();
       int alpha = colorSensor.alpha();
       boolean purple = (red > 100 && blue > 100 && green < 80);


       telemetry.addData("Red", red);
       telemetry.addData("Green", green);
       telemetry.addData("Blue", blue);
       telemetry.update();

           //Switch Servo Time Based
       if(green > red && green > blue && green > 50 /*idk what a good saftety check number is*/ && !switchRunning && !rey12Running) {
           switchRunning = true;
           switchStartTime = runtime.seconds();  // mark the start time
           Switch.setPower(1);

           rey12Running = true;
           rey12StartTime = runtime.seconds();
           rey1.setPower(1);
           rey2.setPower(1);
           }
       if(purple > green && !switchRunning && !rey34Running) {
           switchRunning = true;
           switchStartTime = runtime.seconds();  // mark the start time
           Switch.setPower(-1);

           rey34Running = true;
           rey34StartTime = runtime.seconds();
           rey3.setPower(1);
           rey4.setPower(1);
           }
       // Stop after 3 seconds
       if (switchRunning && runtime.seconds() - switchStartTime > 3.0) {
           Switch.setPower(0);
           switchRunning = false;
       }
       if (rey12Running && runtime.seconds() - rey12StartTime > 3.0){
           rey1.setPower(0);
           rey2.setPower(0);
           rey12Running = false;
       }
       if (rey34Running && runtime.seconds() - rey34StartTime > 3.0){
           rey3.setPower(0);
           rey4.setPower(0);
           rey34Running = false;
       }



       // --- Toggle continuous rotation servos with button B ---
       if (gamepad1.b && !lastBstate) {
           contUp = !contUp;  // flip toggle

           if (contUp) {
               cont1.setPower(-1.0);   // spin forward
               cont2.setPower(1.0);
               cont3.setPower(-1.0);
           } else {
               cont1.setPower(0.0);   // stop spinning
               cont2.setPower(0.0);
               cont3.setPower(0.0);
           }
       }

       lastBstate = gamepad1.b;  // update state

//2 continous motors
       if(gamepad1.x && !lastXstate){
           xUp = !xUp;
           if(xUp){
               spin.setPower(-1);
               twin.setPower(1);
           } else{
               spin.setPower(0);
               twin.setPower(0);
           }
       }
       lastXstate = gamepad1.x;
       // Servos Between 0 and 90 degrees
       if(gamepad1.y && !lastYstate){
           yUp = !yUp;
           if(yUp){
               burn.setPower(-1);
               turn.setPower(1);
           } else{
               burn.setPower(0);
               turn.setPower(0);
           }

       } lastYstate = gamepad1.y;
       if(gamepad1.a && !lastAstate){
           aUp = !aUp;
           if(aUp){
               lurn.setPower(-1);
           } else{
               lurn.setPower(0);
           }

       }
       lastAstate = gamepad1.a;
     /* I don't think these motors are staying on the robot? - If they are they are on same control as new servos
      if(gamepad1.dpad_up && !lastupstate){
           up = !up;
           Up.setPower(up ? 1 : 0);
           Bup.setPower(up ? 1 : 0);
       }
       lastupstate = gamepad1.dpad_up;

       if(gamepad1.dpad_down && !lastdownstate){
           down = !down;
           Up.setPower(up ? 1 : 0);
           Bup.setPower(up ? 1 : 0);
       }
       lastdownstate = gamepad1.dpad_down;
      */

       // to move up further take from ro add to bo in equal portions
       if(gamepad1.dpad_up){
           ro.setPosition(0.93);
           bo.setPosition(0.53);
       }
       if(gamepad1.dpad_down){
           ro.setPosition(0.97);
           bo.setPosition(0.5);
       }
   if(gamepad1.dpad_left){
    leftGate.setPosition(0.5);
    leftMove.setPosition(0.5);
    leftRunning = true;
    leftStartTime = runtime.seconds();

       rightGate.setPosition(0.5);
       rightMove.setPosition(0.5);
       rightRunning = true;
       rightStartTime = runtime.seconds();
   }
   if(leftRunning && runtime.seconds() - leftStartTime > 1.0 ){
       leftGate.setPosition(0);
       leftMove.setPosition(0);
       leftRunning = false;
   }
       if(rightRunning && runtime.seconds() - rightStartTime > 1.0 ){
           rightGate.setPosition(0);
           rightMove.setPosition(0);
           rightRunning = false;
       }
   }
}









